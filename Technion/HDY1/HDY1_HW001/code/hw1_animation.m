%% HDY1 HW001 Animation
% Creates an animation of the falling cat robot from simulation data.
% Reads 'assignment5_data.mat' generated by hw1_symbolic_numeric_calc.m

clear; clc; close all;

% Setup paths
scriptPath = mfilename('fullpath');
if isempty(scriptPath)
    scriptPath = which('hw1_animation');
end
scriptDir = fileparts(scriptPath);
projectDir = fileparts(scriptDir);
videoDir = fullfile(projectDir, 'videos');
if ~exist(videoDir, 'dir')
    mkdir(videoDir);
end

% Load data
dataFile = fullfile(scriptDir, 'assignment5_data.mat');
if ~isfile(dataFile)
    error('Data file "%s" not found. Run hw1_symbolic_numeric_calc.m to generate it.', dataFile);
end
load(dataFile, 't_state', 'qb', 'phi_hist', 'params', 't_final', 'dt');

% Extract parameters
ell = params.ell;
L = 2 * ell; % Length of each link

% Parse states
% qb = [x, y, theta]
x = qb(:, 1);
y = qb(:, 2);
theta = qb(:, 3);
phi1 = phi_hist(:, 1);
phi2 = phi_hist(:, 2);

% Animation settings
fps = 30;
playbackSpeed = 1.0; % Real-time
frameStep = round(1 / (dt * fps * playbackSpeed));
frames = 1:frameStep:length(t_state);

videoFile = fullfile(videoDir, 'HDY1_HW001_Animation.mp4');
v = VideoWriter(videoFile, 'MPEG-4');
v.Quality = 95;
v.FrameRate = fps;
open(v);

% Create figure
fig = figure('Position', [100, 100, 800, 600], 'Color', 'w');
ax = axes('Parent', fig);
axis equal;
grid on;
box on;
hold(ax, 'on');

% Initialize plot objects
% Colors
colorLink0 = [0 0.4470 0.7410]; % Blue
colorLink1 = [0.8500 0.3250 0.0980]; % Orange
colorLink2 = [0.9290 0.6940 0.1250]; % Yellow
lw = 3;
ms = 6;

hLink0 = plot(ax, [0 0], [0 0], 'Color', colorLink0, 'LineWidth', lw, 'Marker', 'o', 'MarkerSize', ms, 'MarkerFaceColor', colorLink0);
hLink1 = plot(ax, [0 0], [0 0], 'Color', colorLink1, 'LineWidth', lw, 'Marker', 'o', 'MarkerSize', ms, 'MarkerFaceColor', colorLink1);
hLink2 = plot(ax, [0 0], [0 0], 'Color', colorLink2, 'LineWidth', lw, 'Marker', 'o', 'MarkerSize', ms, 'MarkerFaceColor', colorLink2);
hTitle = title(ax, sprintf('Time: %.2f s', 0));

xlabel(ax, 'x [m]');
ylabel(ax, 'y [m]');

% Set axis limits relative to center of mass (tracking)
% We want to see the rotation, so we center on (x,y)
viewWidth = 4 * L; 
viewHeight = 3 * L;

fprintf('Generating animation...\n');

for i = frames
    cur_t = t_state(i);
    
    % Current coordinates
    cx = x(i);
    cy = y(i);
    th = theta(i);
    p1 = phi1(i);
    p2 = phi2(i);
    
    % Calculate key points
    % Link 0 (middle) endpoints: Joint 1 (left) and Joint 2 (right)
    % Joint 1 is at: center - ell * vector(theta)
    % Joint 2 is at: center + ell * vector(theta)
    
    vec_th = [cos(th); sin(th)];
    j1 = [cx; cy] - ell * vec_th;
    j2 = [cx; cy] + ell * vec_th;
    
    % Link 1 (left) extends from j1
    % Angle is theta + phi1 relative to link 0?
    % Note: In the derivation:
    % r1 center = [x - ell*cos(theta) - ell*cos(theta+phi1); ...]
    % This implies Link 1 is attached at j1, and its center is ell away at angle (theta+phi1).
    % So the far end is 2*ell away.
    % Wait, let's verify direction. 
    % r1 = j1 - ell * [cos(theta+phi1); sin(theta+phi1)].
    % This means the link extends "backwards" or "negative" direction relative to the angle?
    % Or simply the vector from J1 to Center1 is -ell*[...].
    % Usually links are defined outward.
    % r0 = [x, y]
    % r1 = r0 - ell*u0 - ell*u1  (where u0 is along link0, u1 along link1)
    % So Link 1 vector from J1 is -2*ell * u1? Or does it extend in direction (theta+phi1)?
    % Let's look at r1 def: x - ell c(th) - ell c(th+phi1).
    % J1 is at x - ell c(th).
    % So Center1 is J1 - ell c(th+phi1).
    % This implies the link extends in the direction of -(theta+phi1) from J1?
    % Or rather, the vector FROM the joint TO the tip is -2*ell * [cos(theta+phi1), sin(theta+phi1)].
    % Let's visually assume Link 1 is the "tail" or "left" leg.
    
    vec_ang1 = [cos(th + p1); sin(th + p1)];
    p1_tip = j1 - 2 * ell * vec_ang1;
    
    % Link 2 (right)
    % r2 = x + ell c(th) + ell c(th+phi2).
    % J2 is at x + ell c(th).
    % Center2 is J2 + ell c(th+phi2).
    % So Link 2 extends in direction +(theta+phi2) from J2.
    vec_ang2 = [cos(th + p2); sin(th + p2)];
    p2_tip = j2 + 2 * ell * vec_ang2;
    
    % Update plots
    % Link 0: j1 to j2
    set(hLink0, 'XData', [j1(1), j2(1)], 'YData', [j1(2), j2(2)]);
    
    % Link 1: j1 to p1_tip
    set(hLink1, 'XData', [j1(1), p1_tip(1)], 'YData', [j1(2), p1_tip(2)]);
    
    % Link 2: j2 to p2_tip
    set(hLink2, 'XData', [j2(1), p2_tip(1)], 'YData', [j2(2), p2_tip(2)]);
    
    set(hTitle, 'String', sprintf('Time: %.2f s', cur_t));
    
    % Update axis to track robot
    xlim(ax, [cx - viewWidth/2, cx + viewWidth/2]);
    ylim(ax, [cy - viewHeight/2, cy + viewHeight/2]);
    
    drawnow;
    
    frame = getframe(fig);
    writeVideo(v, frame);
end

close(v);
close(fig);
fprintf('Animation saved to %s\n', videoFile);

