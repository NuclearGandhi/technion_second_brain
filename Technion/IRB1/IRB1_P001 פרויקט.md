---
aliases: 
title: "Project - UR5e Robot Trajectory Planning for Triangle Painting"
---


**Introduction to Robotics (035001) | Spring Semester 2025**

| Ido Fang Bentov                | Nir Karl                       | Ofir Rubin                       |
| ------------------------------ | ------------------------------ | -------------------------------- |
| 322869140                      | 322437203                      | 211544275                        |
| ido.fang@campus.technion.ac.il | nir.karl@campus.technion.ac.il | ofir.rubin@campus.technion.ac.il |


<div><hr><hr></div>


## Problem Description

An industrial 6-DOF Universal Robots UR5e manipulator is deployed in a door manufacturing facility to paint decorative triangular shapes on doors moving on a conveyor belt. The robot holds a $\pu{0.6kg}$ paint sprayer, which must maintain a perpendicular orientation to the door surface with the nozzle positioned $0.05$ to $\pu{0.2m}$ away for uniform paint deposition.

The doors arrive vertically on a conveyor belt moving at a constant velocity of $\pu{0.3m.s^{-1}}$ without stopping. Each triangle has equal sides of $\pu{0.4m}$ and must be painted within $5$ seconds while the door is in motion.

### Key Assumptions

1. Each robot link weighs $\pu{7kg}$ with center of mass at the midpoint between neighboring joints
2. Paint sprayer nozzle remains perpendicular to the door at all times
3. UR5e specifications are used for all kinematic and dynamic constraints

---

## Assignment Solutions

### Assignment 1: Robot Placement


We positioned the robot base at the origin of the world coordinate system: $(0, 0, 0)$ m. This choice establishes a standard reference frame and simplifies all kinematic calculations.

The door surface is positioned at $Y = \pu{0.4m}$ from the robot base. Given the nozzle distance requirement of $\pu{0.05m}$ to $\pu{0.2m}$, we selected $\pu{0.1m}$ for optimal paint deposition. Therefore, the nozzle operates at $Y = \pu{0.3m}$.

The triangle is positioned with its bottom center at $Z = \pu{-0.2m}$ (below the robot base level). For an equilateral triangle with $\pu{0.4m}$ sides, the height is:

$$h = \frac{0.4\sqrt{3}}{2} = \pu{0.346m}$$

![[IRB1_P001 פרויקט 2025-10-25 15.54.53.excalidraw.svg|600]]^figure-cs
>Robot placement schematic showing the coordinate system, robot base at origin, door surface at $Y = \pu {0.4m }$, and triangle positioned with bottom center at $Z = \pu {-0.2m }$.

**Reach Verification:**

The maximum reach occurs at the triangle's top vertex when the door is at maximum X displacement. The top vertex is at:
- $X_{\text{max}} = 0 + 0.45 = \pu{0.45m}$ (triangle center at $X=0$, plus maximum door offset)
- $Y = \pu{0.3m}$ (nozzle distance)
- $Z_{\text{top}} = 0.146\,\pu{m}$ (triangle top vertex)

Maximum reach distance:

$$\begin{aligned}
\text{Distance}_{\text{max}}   = \sqrt{(0.45)^{2} + (0.3)^{2} + (0.146)^{2}} = \pu{0.560m}
\end{aligned}$$

This is well within the robot's maximum reach ($\pu{0.560m} < \pu{0.85m}$).

**Justification:**

1. The door at $Y = \pu{0.4m}$ allows comfortable nozzle positioning at $Y = \pu{0.3m}$
2. The triangle's vertical position ($Z = \pu{-0.2m}$ to $\pu{0.146m}$) is within the robot's optimal workspace
3. All via-points remain within reach despite conveyor motion with $\pu{290mm}$ safety margin (34.1%)
4. The configuration avoids singularities in the primary working region

![[plots/triangle_trajectory.png|600|bookhue]]^figure-trajectory
>Triangle trajectory visualization showing the 3D path (left) and XZ projection (right). The path accounts for conveyor motion during painting.

<div><hr><hr></div>

### Assignment 2: Via-Points Trajectory

**Triangle Geometry:**

For an equilateral triangle with $\pu{40cm}$ sides positioned with bottom center at $(0, \pu{-0.2m})$ in the door frame:

- Vertex 1 (top): $(0.000, 0.146)$ m
- Vertex 2 (bottom right): $(0.200, -0.200)$ m  
- Vertex 3 (bottom left): $(-0.200, -0.200)$ m

**Via-Point Generation Strategy:**

We generated $301$ via-points distributed evenly along the triangle's perimeter:
- Approximately 100 points per side
- Path order: V1 → V2 → V3 → V1 (closed loop)
- Sampling interval: $\pu{0.01s}$ as specified

**Conveyor Synchronization:**

The critical challenge is that the door moves $\pu{0.9m}$ during the 3-second painting time (at $\pu{0.3m/s}$). To keep the end-effector within reach, we offset the door's initial position such that the painting trajectory is centered around $X = 0$:

$$X_{\text{offset}} = -\frac{v_{\text{conv}} \cdot t_{\text{total}}}{2} = -\frac{0.3 \times 3}{2} = \pu{-0.45m}$$

At each via-point $i$ at time $t_{i}$:

$$\begin{aligned}
X_{i} &= X_{\text{triangle}}(i) + X_{\text{offset}} + v_{\text{conv}} \cdot t_{i} \\
Y_{i} &= 0.30 \text{ m (constant nozzle distance)} \\
Z_{i} &= Z_{\text{triangle}}(i)
\end{aligned}$$

This approach keeps the end-effector X-coordinate range within $[\pu{-0.45m}, \pu{0.45m}]$, maintaining excellent reachability.

**Position Accuracy:**

The total expected position error has three main sources:

1. **Via-point discretization**: With $301$ points along $\pu{1.2m}$ perimeter, spacing is $\pu{4.0mm}$. When the robot uses cubic spline interpolation between discrete via-points on the straight triangle edges, the actual path deviates slightly from the ideal geometry. For a $\pu{4mm}$ chord on a curve, the maximum deviation is approximately:
   $$\delta \approx \frac{s^2}{8R} \approx \frac{(0.004)^2}{8 \times 0.4} \approx 5 \times 10^{-6}\,\pu{m} \approx \pu{0.005mm}$$
   We conservatively estimate $\pu{0.03mm}$ accounting for numerical errors.

2. **IK convergence tolerance**: The inverse kinematics solver converges when position error $< \pu{0.2mm}$ (balancing accuracy with computational efficiency)

3. **Robot repeatability**: The UR5e specification is $\pm\pu{0.03mm}$, which represents the mechanical precision limit

**Total expected error:** Combining these sources, we expect maximum position errors:

$$e_{\text{total}} \approx \sqrt{(0.03)^2 + (0.2)^2 + (0.03)^2} \approx \pu{0.20mm}$$

This is acceptable for the painting application where the spray pattern width ($\sim\pu{1-2mm}$) dominates positioning requirements.

<div><hr><hr></div>

### Assignment 3: Forward Kinematics


We implemented forward kinematics using the Denavit-Hartenberg (DH) convention. For the UR5e, the DH parameters are:

| Joint $i$ | $a_{i}$ ($\pu {m}$) | $\alpha_{i}$ ($\pu {rad}$) | $d_{i}$ ($\pu {m}$) | $\theta_{i}$ |
| --------- | ------------------- | -------------------------- | ------------------- | ------------ |
| $1$       | $0$                 | $\pi/2$                    | $0.163$             | $\theta_{1}$ |
| $2$       | $0.425$             | $0$                        | $0$                 | $\theta_{2}$ |
| $3$       | $0.3922$            | $0$                        | $0$                 | $\theta_{3}$ |
| $4$       | $0$                 | $\pi/2$                    | $0.138$             | $\theta_{4}$ |
| $5$       | $0$                 | $-\pi/2$                   | $0.1$               | $\theta_{5}$ |
| $6$       | $0$                 | $0$                        | $0.1$               | $\theta_{6}$ |


![[IRB1_P001 פרויקט 2025-10-26 22.52.54.excalidraw.svg]]


>UR5e robot coordinate frames according to the Denavit-Hartenberg convention, showing the placement of each joint frame and the corresponding link parameters.

The transformation matrix from frame $i-1$ to frame $i$ is:

$${}^{i-1}T_{i} = \begin{pmatrix}
\cos\theta_{i} & -\sin\theta_{i}\cos\alpha_{i} & \sin\theta_{i}\sin\alpha_{i} & a_{i}\cos\theta_{i} \\
\sin\theta_{i} & \cos\theta_{i}\cos\alpha_{i} & -\cos\theta_{i}\sin\alpha_{i} & a_{i}\sin\theta_{i} \\
0 & \sin\alpha_{i} & \cos\alpha_{i} & d_{i} \\
0 & 0 & 0 & 1
\end{pmatrix}$$

The forward kinematics provides the end-effector position and orientation:

$${}^{0}T_{6} = {}^{0}T_{1} \cdot {}^{1}T_{2} \cdot {}^{2}T_{3} \cdot {}^{3}T_{4} \cdot {}^{4}T_{5} \cdot {}^{5}T_{6}$$

**Implementation:**

The function `forward_kinematics(theta, robot)` computes this transformation for any given joint configuration $\boldsymbol{\theta} = [\theta_{1}, \theta_{2}, \theta_{3}, \theta_{4}, \theta_{5}, \theta_{6}]^{T}$:

```matlab
function [T, T_all] = forward_kinematics(theta, robot)
    % Initialize transformation matrices
    T_all = cell(1, 6);
    T = eye(4);
    
    % Compute each joint transformation
    for i = 1:6
        Ti = dh_matrix(robot.a(i), robot.alpha(i), robot.d(i), theta(i));
        T = T * Ti;
        T_all{i} = T;
    end
end

function T = dh_matrix(a, alpha, d, theta)
    % DH transformation matrix
    T = [cos(theta), -sin(theta)*cos(alpha),  sin(theta)*sin(alpha), a*cos(theta);
         sin(theta),  cos(theta)*cos(alpha), -cos(theta)*sin(alpha), a*sin(theta);
         0,           sin(alpha),              cos(alpha),            d;
         0,           0,                       0,                     1];
end
```

**Symbolic Representation:**

The complete transformation from base to end-effector can be expressed symbolically as:

$${}^{0}T_{6}(\boldsymbol{\theta}) = \prod_{i=1}^{6} {}^{i-1}T_{i}(\theta_{i})$$

where each ${}^{i-1}T_{i}$ follows the DH convention shown above. The resulting end-effector position vector $\mathbf{p}_{ee}(\boldsymbol{\theta})$ contains trigonometric expressions combining all six joint angles. For the UR5e, the full symbolic form still contains hundreds of terms and is not practical to display in full.


<div><hr><hr></div>

### Assignment 4: Inverse Kinematics


The inverse kinematics problem requires finding joint angles $\boldsymbol{\theta}$ given desired end-effector pose $T_{\text{desired}}$.

**Analytical Approach:**

For 6-DOF manipulators like the UR5e with a spherical wrist, we can decouple the problem:

1. **Position problem** (joints 1-3): Determine wrist center position
2. **Orientation problem** (joints 4-6): Determine wrist angles

The wrist center position is:

$$\mathbf{p}_{\text{wrist}} = \mathbf{p}_{\text{desired}} - d_{6} \cdot \mathbf{R}_{\text{desired}} \cdot \begin{pmatrix} 0 \\ 0 \\ 1 \end{pmatrix}$$

For a 6-DOF manipulator, up to 8 analytical solutions may exist due to:
- Joint 1: 2 solutions (elbow left/right)
- Joint 2-3: 2 solutions (elbow up/down)  
- Joint 5: 2 solutions (wrist flip)

**Solution Selection with Collision Avoidance:**

We implement a **constraint-based filtering approach** with collision avoidance:

1. **Joint Angle Limits**: Enforce practical joint limits to avoid extreme configurations
   - Joint 2: $-3\pi/4 \leq \theta_2 \leq \pi/4$ (flexible shoulder range)
   - Joint 3: $-\pi/6 \leq \theta_3 \leq 5\pi/6$ (reasonable elbow angle)

2. **Collision Constraints**: All joint positions must satisfy:
   - **Door constraint**: $Y_{\text{joint}} < Y_{\text{door}} - \pu{0.03m}$ ($\pu{30mm}$ safety margin)
   - **Floor constraint**: $Z_{\text{joint}} > Z_{\text{floor}} + \pu{0.03m}$ ($\pu{30mm}$ safety margin)
   - **Nozzle distance**: $\pu{0.2m} \leq Y_{\text{ee}} \leq \pu{0.35m}$ ($0.05$ to $\pu{0.2m}$ from door at $Y=\pu{0.4m}$)

3. **Selection**: From all collision-free solutions, select the one minimizing:
   $$\text{cost} = 1000 \cdot \|\mathbf{p}_{\text{achieved}} - \mathbf{p}_{\text{desired}}\|^{2} + 0.01 \cdot \|\boldsymbol{\theta} - \boldsymbol{\theta}_{\text{current}}\|^{2}$$
   
   The coefficient $1000$ heavily prioritizes position accuracy (errors in meters become large penalties), while $0.01$ gently encourages smooth motion by penalizing large joint displacements.

**Verification:**

For each via-point, we verify the solution by computing forward kinematics and checking position error:

$$e_{\text{pos}} = \|\mathbf{p}_{\text{achieved}} - \mathbf{p}_{\text{desired}}\| < \pu{0.2mm}$$

<div><hr><hr></div>

**Implementation:**

```matlab
function [theta_all, theta_best] = inverse_kinematics(T_desired, theta_current, robot, door_y, floor_z)
    % Extract desired position and orientation
    p_desired = T_desired(1:3, 4);
    R_desired = T_desired(1:3, 1:3);
    
    % Joint limits with practical constraints
    lb = -2*pi * ones(6,1);
    ub = 2*pi * ones(6,1);
    lb(2) = -3*pi/4; ub(2) = pi/4;   % Shoulder range
    lb(3) = -pi/6;   ub(3) = 5*pi/6; % Elbow range
    
    % Fix joint 6 for consistent orientation
    theta6_fixed = 0;
    Aeq = [0 0 0 0 0 1];
    beq = theta6_fixed;
    
    % Cost function: prioritize position accuracy, penalize large joint motion
    cost_function = @(theta) 1000*norm(forward_kinematics(theta, robot)(1:3,4) - p_desired)^2 ...
                            + 0.01*norm(theta - theta_current)^2;
    
    % Nonlinear collision constraints
    nonlcon = @(theta) collision_constraints(theta, robot, door_y, floor_z);
    
    % Optimization options
    options = optimoptions('fmincon', 'Display', 'off', 'Algorithm', 'sqp', ...
                          'MaxFunctionEvaluations', 5000);
    
    % Try multiple initial guesses
    initial_guesses = [theta_current, zeros(6,1), [0;-pi/4;pi/2;0;pi/2;0]];
    theta_all = [];
    for k = 1:size(initial_guesses, 2)
        theta0 = initial_guesses(:, k);
        [theta_sol, ~] = fmincon(cost_function, theta0, [], [], Aeq, beq, lb, ub, nonlcon, options);
        
        % Verify solution
        [c, ~] = collision_constraints(theta_sol, robot, door_y, floor_z);
        pos_error = norm(forward_kinematics(theta_sol, robot)(1:3,4) - p_desired);
```
```matlab
        if pos_error < 0.0002 && all(c <= 0)  % 0.2mm tolerance
            theta_all = [theta_all, theta_sol];
        end
    end
    
    % Select best solution (smallest joint displacement)
    if ~isempty(theta_all)
        [~, idx] = min(vecnorm(theta_all - theta_current));
        theta_best = theta_all(:, idx);
    else
        theta_best = theta_current; % Fallback
    end
end

function [c, ceq] = collision_constraints(theta, robot, door_y, floor_z)
    % Compute all joint positions
    [~, T_all] = forward_kinematics(theta, robot);
    joint_positions = zeros(3, 7);
    joint_positions(:, 1) = [0; 0; 0];
    for i = 1:6
        joint_positions(:, i+1) = T_all{i}(1:3, 4);
    end
    
    safety_margin = 0.03; % 3 cm clearance
    c = [];
    
    % Door constraint: Y_joint < door_y - safety_margin
    for i = 1:7
        c = [c; joint_positions(2, i) - (door_y - safety_margin)];
    end
    
    % Floor constraint: Z_joint > floor_z + safety_margin
    for i = 1:7
        c = [c; (floor_z + safety_margin) - joint_positions(3, i)];
    end
    
    % Lateral limits: -1m < X < 1m
    for i = 2:7
        c = [c; joint_positions(1, i) - 1.0];
        c = [c; -1.0 - joint_positions(1, i)];
    end
    
    % End-effector Y constraint: 0.2m <= Y_ee <= 0.35m
    ee_pos = joint_positions(:, 7);
    c = [c; (door_y - 0.2) - ee_pos(2)];
    c = [c; ee_pos(2) - (door_y - 0.05)];
    
    ceq = [];
end
```

<div><hr><hr></div>

### Assignment 5: Jacobian Matrix

The Jacobian matrix relates joint velocities to end-effector velocities:

$$\begin{pmatrix} \dot{\mathbf{p}} \\ \boldsymbol{\omega} \end{pmatrix} = \mathbf{J}(\boldsymbol{\theta}) \dot{\boldsymbol{\theta}}$$

where $\dot{\mathbf{p}} \in \mathbb{R}^{3}$ is linear velocity and $\boldsymbol{\omega} \in \mathbb{R}^{3}$ is angular velocity.

**Geometric Jacobian Formulation:**

For each joint $i$, we compute:

$$\mathbf{J}_{i} = \begin{pmatrix} \mathbf{J}_{v,i} \\ \mathbf{J}_{\omega,i} \end{pmatrix}$$

For revolute joints:

$$\begin{aligned}
\mathbf{J}_{v,i} &= \mathbf{z}_{i-1} \times (\mathbf{p}_{6} - \mathbf{p}_{i-1}) \\
\mathbf{J}_{\omega,i} &= \mathbf{z}_{i-1}
\end{aligned}$$

where:
- $\mathbf{z}_{i-1}$ is the joint axis direction (third column of ${}^{0}T_{i-1}$)
- $\mathbf{p}_{i}$ is the position of frame $i$
- $\mathbf{p}_{6}$ is the end-effector position

The full Jacobian is:

$$\mathbf{J}(\boldsymbol{\theta}) = \begin{pmatrix} \mathbf{J}_{v,1} & \mathbf{J}_{v,2} & \mathbf{J}_{v,3} & \mathbf{J}_{v,4} & \mathbf{J}_{v,5} & \mathbf{J}_{v,6} \\ \mathbf{J}_{\omega,1} & \mathbf{J}_{\omega,2} & \mathbf{J}_{\omega,3} & \mathbf{J}_{\omega,4} & \mathbf{J}_{\omega,5} & \mathbf{J}_{\omega,6} \end{pmatrix}_{6 \times 6}$$

**Implementation:**

The function `compute_jacobian(theta, robot)` returns both the full 6×6 Jacobian and the upper 3×6 linear velocity Jacobian for singularity analysis.

The Jacobian $\mathbf{J}(\boldsymbol{\theta})$ can be computed symbolically using the geometric approach or by taking partial derivatives of the forward kinematics. The linear velocity Jacobian is:

$$J_{v,ij} = \frac{\partial p_i}{\partial \theta_j}$$

where $\mathbf{p} = [p_x, p_y, p_z]^T$ is the end-effector position. Due to the UR5e's specific DH parameters, many terms simplify, but the complete symbolic form still contains several hundred terms per matrix element and is not practical for manual display.

<div><hr><hr></div>

**Numerical Implementation:**

```matlab
function [J, J_linear] = compute_jacobian(theta, robot)
    % Compute forward kinematics for all joints
    [~, T_all] = forward_kinematics(theta, robot);
    
    % Initialize Jacobian matrices
    J = zeros(6, 6);
    
    % End-effector position
    p_ee = T_all{6}(1:3, 4);
    
    % For each joint
    for i = 1:6
        if i == 1
            z_prev = [0; 0; 1];  % Base z-axis
            p_prev = [0; 0; 0];   % Base position
        else
            z_prev = T_all{i-1}(1:3, 3);  % Joint axis direction
            p_prev = T_all{i-1}(1:3, 4);   % Joint position
        end
        
        % Linear velocity component: J_v = z × (p_ee - p_joint)
        J(1:3, i) = cross(z_prev, p_ee - p_prev);
        
        % Angular velocity component: J_ω = z
        J(4:6, i) = z_prev;
    end
    
    % Extract linear velocity Jacobian (upper 3 rows)
    J_linear = J(1:3, :);
end
```


<div><hr><hr></div>

### Assignment 6: Singularities

Singularities occur when $\text{rank}(\mathbf{J}_{v}) < 3$, or equivalently when $\det(\mathbf{J}_{v} \mathbf{J}_{v}^{T}) \approx 0$. At singularities, the robot loses one or more degrees of freedom for end-effector motion.

**Singularity Analysis Method:**

To identify singularities systematically, we analyze the linear velocity Jacobian $\mathbf{J}_{v}$ structure. For the UR5e, each column represents:

$$\mathbf{J}_{v,i} = \mathbf{z}_{i-1} \times (\mathbf{p}_{ee} - \mathbf{p}_{i-1})$$

A singularity occurs when these six vectors become linearly dependent (only three independent directions remain). We identify three primary cases:

1. **Wrist singularity**: When $\theta_5 = 0$, the rotation axes of joints 4 and 6 become coplanar, causing the angular velocity Jacobian columns for these joints to lose independence. The robot cannot generate arbitrary rotations - one rotational degree of freedom is lost.

2. **Shoulder singularity**: When $\mathbf{p}_{ee} - \mathbf{p}_0$ is parallel to $\mathbf{z}_0$ (wrist on base axis), the term $\mathbf{z}_0 \times (\mathbf{p}_{ee} - \mathbf{p}_0) = \mathbf{0}$, eliminating one degree of freedom for end-effector translation.

3. **Elbow singularity**: When joints 2 and 3 are collinear ($\theta_2 + \theta_3 \approx 0$ or $\pi$), the arm loses radial mobility as the combined reach of links 2 and 3 cannot be changed - only the position along the extended arm can vary.


**Workspace Visualization:**

![[plots/workspace_3d_singularities.png|600|bookhue]]^figure-workspace
>3D workspace visualization showing the reachable positions of the end-effector. The point cloud represents sampled configurations within the robot's operational range.

**Singularity Avoidance in Our Task:**

Our trajectory planning successfully avoids all singularities by:
1. Maintaining $\theta_{5} \neq 0$ throughout the motion
2. Keeping the wrist center away from the base Z-axis
3. Operating well within the extended/folded limits

<div><hr><hr></div>


### Assignment 7: Trajectory Planning

**7a) Polynomial Selection:**

We use **cubic spline interpolation** with optimized boundary conditions for smooth trajectories. MATLAB's `spline` function creates piecewise cubic polynomials with $C^2$ continuity (continuous second derivatives), ensuring smooth acceleration profiles.

For each joint, the spline is defined with zero endpoint velocities:

$$\text{spline}(t, [0, \boldsymbol{\theta}_{\text{via}}, 0])$$

This creates a smooth trajectory that:
- Passes through all via-points exactly
- Has continuous position, velocity, and acceleration
- Starts and ends with zero velocity (as required)
- Minimizes acceleration discontinuities

**Why Cubic Splines:**

Cubic splines provide an excellent balance between:
1. **Smoothness**: $C^2$ continuity ensures no sudden acceleration changes
2. **Computational efficiency**: Closed-form solution, no optimization required
3. **Stability**: Well-conditioned numerical properties
4. **Flexibility**: Natural interpolation through densely-spaced via-points ($\pu{0.01s}$ intervals)

**7b) Time Interval:**

As specified, we use $\Delta t = \pu{0.01s}$ between via-points for a total time of $\pu{3.0s}$, resulting in $301$ via-points.

**7c) Velocity Constraint Verification:**

UR5e maximum joint velocities: $\pu{180deg.s^{-1}}$ for each joint.

Our trajectory maximum velocities achieved (3-second trajectory):

| Joint | Max Velocity (deg/s) | Limit (deg/s) | Status |
| ----- | -------------------- | ------------- | ------ |
| $1$   | $99.8$               | $180$         | ✓      |
| $2$   | $72.6$               | $180$         | ✓      |
| $3$   | $87.3$               | $180$         | ✓      |
| $4$   | $58.6$               | $180$         | ✓      |
| $5$   | $43.6$               | $180$         | ✓      |
| $6$   | $0.0$                | $180$         | ✓      |

**7d) Timing Requirement:**

We selected $t_{\text{total}} = 3.0$ seconds, which satisfies the requirement of $t \leq 5$ seconds. This timing was chosen to maximize efficiency while maintaining velocity constraints


## Results and Verification

### Constraint Verification Summary

**Joint Torques (with $\pu{0.6kg}$ payload):**

| Joint | Max Torque ($\pu{N.m}$) |
| ----- | ----------------------- |
| $1$   | $0.0$                   |
| $2$   | $162.4$                 |
| $3$   | $84.1$                  |
| $4$   | $12.6$                  |
| $5$   | $3.2$                   |
| $6$   | $0.0$                   |


**Note on Joint Torques:**
- **Joint 1 shows $\pu{0.0N.m}$**: Joint 1 rotates around the vertical Z-axis $[0, 0, 1]^T$, while gravity acts downward $[0, 0, -g]^T$. The gravitational torque is $\boldsymbol{\tau}_1 = \mathbf{z}_1^T (\mathbf{r} \times \mathbf{F}_g)$. Since $\mathbf{r} \times \mathbf{F}_g$ produces a vector in the XY plane (perpendicular to gravity), and $\mathbf{z}_1$ points in Z direction, their dot product is zero. Joint 1 doesn't fight gravity - it only provides lateral positioning.
- **Joint 6 shows $\pu{0.0N.m}$**: Maintains constant orientation ($\theta_6 = 0$) throughout the trajectory with no payload torque about the wrist axis.
- **Joint 2 (shoulder)** has the highest torque requirement as it supports the entire arm weight plus payload against gravity with a large moment arm.

<div><hr><hr></div>

![[plots/joint_positions.png|600|bookhue]]^figure-joint-pos
>Joint position trajectories showing smooth motion profiles for all six joints throughout the 3-second painting cycle.

![[plots/joint_velocities.png|600|bookhue]]^figure-joint-vel
>Joint velocity profiles with maximum velocity indicators (red stars) and velocity limits (red dashed lines). All velocities remain well within specifications.

<div><hr><hr></div>

![[plots/joint_torques.png|600|bookhue]]^figure-static-joint-torque
>Static joint torques computed for $\pu{0.6kg}$ payload, showing maximum torque requirements at each joint.

![[plots/ee_trajectory_3d.png|600|bookhue]]^figure-3d-end-effector-traj
>3D end-effector trajectory showing the triangular paint path in the robot's workspace, with coordinate frame and door surface representation.

<div><hr><hr></div>

![[plots/robot_snapshots.png|600|bookhue]]^figure-configs
>Robot configurations at key time points during the painting trajectory: start (left), midpoint (center), and end (right). The visualization shows the robot's pose and end-effector position throughout the task.