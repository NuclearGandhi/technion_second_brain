/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file           : main.c
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include <math.h>
#include <stdio.h>
#include <string.h>

#include "uart.h"

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
#define NP 1000

#define two_pi 6.2831853071795862
#define ABS(X) ((X < 0) ? (-X) : (X))
#define SAT(X) ((X > 100.0) ? (100.0) : (X))
#define SAT10k(X) ((X > 9999) ? (9999) : (X))
#define SATI16(X) ((X > 9999) ? (9999) : ((X < -9999) ? (-9999) : (X)))
#define RX_CMD_LEN 8
#define RX_BUF_LEN 16
#define TX_BUF_LEN 64
#define NO_RX_DATA 0
#define NEW_RX_DATA 1
#define TX_READY 0
#define TX_BUSY 1
#define STEP_SIZE 4400
#define SGN(X) ((X > 0) - (X < 0))
#define UART &hlpuart1

// Mecanum wheel geometry (meters)
#define WHEEL_RADIUS 0.030f  // 30mm wheel radius
#define WHEEL_BASE_L 0.080f  // half of wheelbase (front-back)
#define WHEEL_BASE_W 0.075f  // half of track width (left-right)
#define L_PLUS_W (WHEEL_BASE_L + WHEEL_BASE_W)

// Encoder conversion: encoder counts per revolution / 2*pi
#define ENCODER_CPR 1320  // counts per revolution (x4 mode: 4 * encoder lines)
#define COUNTS_TO_RAD (two_pi / ENCODER_CPR)

// Control loop frequency
#define CONTROL_FREQ 100.0f  // 100 Hz control loop
#define CONTROL_DT (1.0f / CONTROL_FREQ)

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;
ADC_HandleTypeDef hadc5;

UART_HandleTypeDef hlpuart1;
UART_HandleTypeDef huart3;

TIM_HandleTypeDef htim1;
TIM_HandleTypeDef htim2;
TIM_HandleTypeDef htim3;
TIM_HandleTypeDef htim4;
TIM_HandleTypeDef htim5;
TIM_HandleTypeDef htim8;
TIM_HandleTypeDef htim15;
TIM_HandleTypeDef htim20;

/* USER CODE BEGIN PV */

uint16_t ind, scan = 0, print, d = 100;
uint16_t tic = 50;
int16_t enc1, enc2, enc3, enc4;
uint8_t msg[40], stop, TestMode;
uint8_t pSensor = 0;
int16_t x = 1;

float u;
float u1;
float u2;
int16_t enc_k;
int16_t Enc_k[4];
int16_t enc_k1;
int16_t Enc_k1[4];
int16_t enc_k2;
int16_t Enc_k2[4];

int16_t ref = 0;
int16_t Ref[4] = {0, 0, 0, 0};  // Velocity reference for each wheel (encoder counts per sample)

uint16_t d2, PWM1, PWM2, PWM3, PWM13, OC1, OC2, DELAY, flag = 0;
int16_t Pwm[4];
uint16_t pa1 = 0, pa4 = 0, pb0 = 0;
int16_t REC[NP][5], ch = 0, s = 1;

uint16_t mode = STATE_IDLE;
uint16_t drive_mode = 0;

extern volatile uint8_t uart_rx_flag;
extern volatile uint8_t uart_tx_flag;

int16_t Enc[4], Enc1[4], Enc2[4], ka = 0;

// PI Controller variables
float kp = 1.43f;
float ki = 0.2106f;
float kd = 0.0f;
int16_t E[4] = {0};   // Current error
int16_t E1[4] = {0};  // Previous error
int16_t E2[4] = {0};  // Two samples ago error
float U[4] = {0};     // Control output (integrator state)

int16_t W = 0, W1 = 0, W2 = 0;
int16_t We[4], We1[4], We2[4];  // Wheel velocities (encoder counts per sample)
int32_t Enc32[4] = {0};         // Extended encoder counts (prevent overflow)

// Motor direction signs (for kinematics reference calculation)
// All +1 when encoder signs are configured correctly
int16_t motor_sign[4] = {-1, 1, -1, 1};

// Kinematics control variables
float vx_ref = 0.0f;  // Cart velocity x (m/s)
float vy_ref = 0.0f;  // Cart velocity y (m/s)
float wz_ref = 0.0f;  // Cart angular velocity (rad/s)

// Trajectory following variables
volatile uint32_t traj_index = 0;
volatile uint8_t traj_running = 0;
volatile uint32_t traj_next_time = 0;

// Obstacle detection
volatile uint8_t obstacle_detected = 0;
volatile uint8_t obstacle_stop_enabled = 1;

// Include trajectory data (generated by MATLAB)
#include "trajectory.h"

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_TIM1_Init(void);
static void MX_TIM2_Init(void);
static void MX_TIM3_Init(void);
static void MX_TIM4_Init(void);
static void MX_TIM5_Init(void);
static void MX_TIM8_Init(void);
static void MX_TIM15_Init(void);
static void MX_ADC5_Init(void);
static void MX_TIM20_Init(void);
static void MX_ADC1_Init(void);
static void MX_LPUART1_UART_Init(void);
static void MX_USART3_UART_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/**
 * @brief Set PWM outputs for all 4 motors
 * @param Pwm Array of PWM values (-9999 to 9999) for each motor
 */
void set_pwm(int16_t Pwm[]) {
    float temp1, temp2;

    // Motor 0 direction pins
    HAL_GPIO_WritePin(GPIOC, GPIO_PIN_2, Pwm[0] * motor_sign[0] < 0);
    HAL_GPIO_WritePin(GPIOC, GPIO_PIN_3, (Pwm[0] * motor_sign[0] > 0));

    // Motor 1 direction pins
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_4, (Pwm[1] * motor_sign[1] < 0));
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, (Pwm[1] * motor_sign[1] > 0));

    // Motor 2 direction pins
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_11, (Pwm[2] * motor_sign[2] < 0));
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_6, (Pwm[2] * motor_sign[2] > 0));

    // Motor 3 direction pins
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13, (Pwm[3] * motor_sign[3] < 0));
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, (Pwm[3] * motor_sign[3] > 0));

    // Set PWM duty cycle (magnitude only)
    temp1 = Pwm[0];
    temp2 = Pwm[1];
    TIM2->CCR1 = (uint16_t)SAT10k(ABS(temp1));
    TIM2->CCR2 = (uint16_t)SAT10k(ABS(temp2));

    temp1 = Pwm[2];
    temp2 = Pwm[3];
    TIM2->CCR3 = (uint16_t)SAT10k((ABS(temp1)));
    TIM2->CCR4 = (uint16_t)SAT10k((ABS(temp2)));
}

/**
 * @brief Read encoders and compute wheel velocities (open-loop, just reads)
 *        Encoder signs are applied so that forward motion = positive velocity
 */
void read_encoders(void) {
    // Store previous values
    for (int q = 0; q < 4; q++) {
        Enc2[q] = Enc1[q];
        Enc1[q] = Enc[q];
        We2[q] = We1[q];
        We1[q] = We[q];
    }

    // Read current encoder values with sign correction
    Enc[0] = motor_sign[0] * (int16_t)TIM1->CNT;
    Enc[1] = motor_sign[1] * (int16_t)TIM8->CNT;
    Enc[2] = motor_sign[2] * (int16_t)TIM3->CNT;
    Enc[3] = motor_sign[3] * (int16_t)TIM4->CNT;

    // Compute wheel velocities (encoder counts per sample)
    for (int q = 0; q < 4; q++) {
        We[q] = Enc[q] - Enc1[q];
        Enc32[q] += (int32_t)We[q];  // Accumulate for position tracking
    }
}

/**
 * @brief Basic PID function (open-loop mode, just reads encoders and sets PWM)
 */
void pid(void) {
    read_encoders();
    set_pwm(Pwm);
}

/**
 * @brief PI Velocity Controller for all 4 wheels
 *        Implements incremental PI: du = ki*E + kp*(E-E1)
 *        Control law: U[q] += du (with saturation)
 */
void velocity_pid(void) {
    float du;

    read_encoders();

    for (int q = 0; q < 4; q++) {
        // Store previous error
        E1[q] = E[q];

        // Compute velocity error (reference - measured)
        E[q] = Ref[q] - We[q];

        // Incremental PI control
        du = ki * (float)E[q] + kp * (float)(E[q] - E1[q]);
        U[q] += du;

        // Saturate control output
        if (U[q] > 9999.0f) U[q] = 9999.0f;
        if (U[q] < -9999.0f) U[q] = -9999.0f;

        // Apply to PWM
        Pwm[q] = (int16_t)U[q];
    }

    set_pwm(Pwm);
}

/**
 * @brief Reset PI controller integrators
 */
void reset_pid(void) {
    for (int q = 0; q < 4; q++) {
        E[q] = 0;
        E1[q] = 0;
        E2[q] = 0;
        U[q] = 0;
    }
}

/**
 * @brief Convert cart velocities (vx, vy, wz) to wheel velocity references
 *        Using Mecanum wheel inverse kinematics
 *
 * Wheel arrangement (top view):
 *   FL(0) -------- FR(1)
 *     |     ^x     |
 *     |     |      |
 *     |  y<-+      |
 *   RL(2) -------- RR(3)
 *
 * Mecanum equations:
 *   omega_FL = (vx - vy - (L+W)*wz) / r
 *   omega_FR = (vx + vy + (L+W)*wz) / r
 *   omega_RL = (vx + vy - (L+W)*wz) / r
 *   omega_RR = (vx - vy + (L+W)*wz) / r
 */
void kinematics_to_wheel_vel(float vx, float vy, float wz) {
    float omega[4];

    // Compute wheel angular velocities (rad/s)
    omega[0] = (vx - vy - L_PLUS_W * wz) / WHEEL_RADIUS;  // FL
    omega[1] = (vx + vy + L_PLUS_W * wz) / WHEEL_RADIUS;  // FR
    omega[2] = (vx + vy - L_PLUS_W * wz) / WHEEL_RADIUS;  // RL
    omega[3] = (vx - vy + L_PLUS_W * wz) / WHEEL_RADIUS;  // RR

    // Convert to encoder counts per sample period
    // counts/sample = (rad/s) * (counts/rad) * (s/sample)
    for (int q = 0; q < 4; q++) {
        float counts_per_sec = omega[q] / COUNTS_TO_RAD;
        Ref[q] = (int16_t)(counts_per_sec * CONTROL_DT);
    }
}

/**
 * @brief Record encoder data for system identification
 */
void record_enc(void) {
    if (mode == STATE_SQUARE) {
        REC[ka][0] = Pwm[0];
        REC[ka][1] = Enc[0];
        REC[ka][2] = Enc[1];
        REC[ka][3] = Enc[2];
        REC[ka][4] = Enc[3];
        ka++;

        if (ka == NP) {
            mode = STATE_IDLE;
            ka = 0;
            Pwm[0] = Pwm[1] = Pwm[2] = Pwm[3] = 0;
            reset_pid();
            pid();
        }
    }
}

/**
 * @brief Set drive mode PWM based on predefined directions (open-loop)
 */
void set_drive_pwm(void) {
    int16_t speed = 3000;
    int16_t p[4] = {0};

    switch (drive_mode) {
        case MODE_F:  // Forward
            p[0] = speed;
            p[1] = speed;
            p[2] = speed;
            p[3] = speed;
            break;
        case MODE_B:  // Backward
            p[0] = -speed;
            p[1] = -speed;
            p[2] = -speed;
            p[3] = -speed;
            break;
        case MODE_CW:  // Clockwise rotation
            p[0] = -speed;
            p[1] = speed;
            p[2] = speed;
            p[3] = -speed;
            break;
        case MODE_CCW:  // Counter-clockwise rotation
            p[0] = speed;
            p[1] = -speed;
            p[2] = -speed;
            p[3] = speed;
            break;
        case MODE_NW:  // Diagonal NW
            p[0] = 0;
            p[1] = speed;
            p[2] = 0;
            p[3] = speed;
            break;
        case MODE_SE:  // Diagonal SE
            p[0] = 0;
            p[1] = -speed;
            p[2] = 0;
            p[3] = -speed;
            break;
        case MODE_NE:  // Diagonal NE
            p[0] = speed;
            p[1] = 0;
            p[2] = speed;
            p[3] = 0;
            break;
        case MODE_SW:  // Diagonal SW
            p[0] = -speed;
            p[1] = 0;
            p[2] = -speed;
            p[3] = 0;
            break;
        default:
            p[0] = 0;
            p[1] = 0;
            p[2] = 0;
            p[3] = 0;
            break;
    }
}

/**
 * @brief Check obstacle sensor and update flag
 */
void check_obstacle(void) {
    pSensor = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_7);
    obstacle_detected = (pSensor == 0);

    // Visual feedback on LED
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, obstacle_detected);
}

/**
 * @brief Start trajectory execution using TIM5 output compare
 */
void start_trajectory(void) {
    if (traj_running) return;

    traj_index = 0;
    traj_running = 1;
    reset_pid();

    // Initialize TIM5 for output compare
    __HAL_TIM_SET_COUNTER(&htim5, 0);

    // Set first compare value
    if (traj_index < tt_clk_len) {
        traj_next_time = tt_clk[traj_index];
        __HAL_TIM_SET_COMPARE(&htim5, TIM_CHANNEL_2, traj_next_time);
    }

    // Start TIM5 in output compare interrupt mode
    HAL_TIM_OC_Start_IT(&htim5, TIM_CHANNEL_2);

    // Apply first trajectory point
    if (traj_index < vt_len) {
        int16_t vel = vt[traj_index];
        // For now, apply same velocity to all wheels (forward motion)
        // This will be enhanced for full kinematics
        Ref[0] = vel * motor_sign[0];
        Ref[1] = vel * motor_sign[1];
        Ref[2] = vel * motor_sign[2];
        Ref[3] = vel * motor_sign[3];
    }
}

/**
 * @brief Stop trajectory execution
 */
void stop_trajectory(void) {
    traj_running = 0;
    HAL_TIM_OC_Stop_IT(&htim5, TIM_CHANNEL_2);

    // Stop motors
    Ref[0] = Ref[1] = Ref[2] = Ref[3] = 0;
    reset_pid();
}

/**
 * @brief TIM5 Output Compare callback for trajectory timing
 */
void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef* htim) {
    if (htim->Instance == TIM5 && htim->Channel == HAL_TIM_ACTIVE_CHANNEL_2) {
        if (!traj_running) return;

        traj_index++;

        // Check for end of trajectory (special value 9999)
        if (traj_index >= vt_len || vt[traj_index] == 9999) {
            stop_trajectory();
            mode = STATE_IDLE;
            return;
        }

        // Apply next trajectory point
        int16_t vel = vt[traj_index];
        Ref[0] = vel * motor_sign[0];
        Ref[1] = vel * motor_sign[1];
        Ref[2] = vel * motor_sign[2];
        Ref[3] = vel * motor_sign[3];

        // Schedule next interrupt
        if (traj_index < tt_clk_len) {
            traj_next_time += tt_clk[traj_index];
            __HAL_TIM_SET_COMPARE(&htim5, TIM_CHANNEL_2, traj_next_time);
        }
    }
}

/* USER CODE END 0 */

/**
 * @brief  The application entry point.
 * @retval int
 */
int main(void) {
    /* USER CODE BEGIN 1 */

    /* USER CODE END 1 */

    /* MCU Configuration--------------------------------------------------------*/

    /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
    HAL_Init();

    /* USER CODE BEGIN Init */

    /* USER CODE END Init */

    /* Configure the system clock */
    SystemClock_Config();

    /* USER CODE BEGIN SysInit */

    /* USER CODE END SysInit */

    /* Initialize all configured peripherals */
    MX_GPIO_Init();
    MX_TIM1_Init();
    MX_TIM2_Init();
    MX_TIM3_Init();
    MX_TIM4_Init();
    MX_TIM5_Init();
    MX_TIM8_Init();
    MX_TIM15_Init();
    MX_ADC5_Init();
    MX_TIM20_Init();
    MX_ADC1_Init();
    MX_LPUART1_UART_Init();
    MX_USART3_UART_Init();
    /* USER CODE BEGIN 2 */
    init_uart2();

    // Start PWM for all 4 motors
    HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);
    HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_2);
    HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_3);
    HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_4);

    HAL_TIM_PWM_Start(&htim20, TIM_CHANNEL_3);  // Servo PWM

    // Initialize PWM to 0
    __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_1, 0);
    __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_2, 0);
    __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_3, 0);
    __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_4, 0);

    // Start encoder timers
    HAL_TIM_Encoder_Start(&htim1, TIM_CHANNEL_ALL);
    HAL_TIM_Encoder_Start(&htim8, TIM_CHANNEL_ALL);
    HAL_TIM_Encoder_Start(&htim3, TIM_CHANNEL_ALL);
    HAL_TIM_Encoder_Start(&htim4, TIM_CHANNEL_ALL);

    // Start TIM5 base for trajectory timing
    HAL_TIM_Base_Start(&htim5);

    // Start control loop timer interrupt (TIM15 @ 100Hz)
    HAL_TIM_Base_Start_IT(&htim15);

    // Initialize PI controller
    reset_pid();

    TestMode = stop = 0;
    /* USER CODE END 2 */

    /* Infinite loop */
    /* USER CODE BEGIN WHILE */
    while (1) {
        HAL_Delay(10);
        handle_comm();

        // Check obstacle sensor periodically
        check_obstacle();
        /* USER CODE END WHILE */

        /* USER CODE BEGIN 3 */
    }
    /* USER CODE END 3 */
}

/**
 * @brief System Clock Configuration
 * @retval None
 */
void SystemClock_Config(void) {
    RCC_OscInitTypeDef RCC_OscInitStruct = {0};
    RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

    /** Configure the main internal regulator output voltage
     */
    HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST);

    /** Initializes the RCC Oscillators according to the specified parameters
     * in the RCC_OscInitTypeDef structure.
     */
    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
    RCC_OscInitStruct.HSIState = RCC_HSI_ON;
    RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
    RCC_OscInitStruct.PLL.PLLM = RCC_PLLM_DIV4;
    RCC_OscInitStruct.PLL.PLLN = 85;
    RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
    RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
    RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
        Error_Handler();
    }

    /** Initializes the CPU, AHB and APB buses clocks
     */
    RCC_ClkInitStruct.ClockType =
        RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK) {
        Error_Handler();
    }
}

/**
 * @brief ADC1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_ADC1_Init(void) {
    /* USER CODE BEGIN ADC1_Init 0 */

    /* USER CODE END ADC1_Init 0 */

    ADC_MultiModeTypeDef multimode = {0};
    ADC_ChannelConfTypeDef sConfig = {0};

    /* USER CODE BEGIN ADC1_Init 1 */

    /* USER CODE END ADC1_Init 1 */

    /** Common config
     */
    hadc1.Instance = ADC1;
    hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
    hadc1.Init.Resolution = ADC_RESOLUTION_12B;
    hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
    hadc1.Init.GainCompensation = 0;
    hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
    hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
    hadc1.Init.LowPowerAutoWait = DISABLE;
    hadc1.Init.ContinuousConvMode = DISABLE;
    hadc1.Init.NbrOfConversion = 1;
    hadc1.Init.DiscontinuousConvMode = DISABLE;
    hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
    hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
    hadc1.Init.DMAContinuousRequests = DISABLE;
    hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
    hadc1.Init.OversamplingMode = DISABLE;
    if (HAL_ADC_Init(&hadc1) != HAL_OK) {
        Error_Handler();
    }

    /** Configure the ADC multi-mode
     */
    multimode.Mode = ADC_MODE_INDEPENDENT;
    if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK) {
        Error_Handler();
    }

    /** Configure Regular Channel
     */
    sConfig.Channel = ADC_CHANNEL_12;
    sConfig.Rank = ADC_REGULAR_RANK_1;
    sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;
    sConfig.SingleDiff = ADC_SINGLE_ENDED;
    sConfig.OffsetNumber = ADC_OFFSET_NONE;
    sConfig.Offset = 0;
    if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK) {
        Error_Handler();
    }
    /* USER CODE BEGIN ADC1_Init 2 */

    /* USER CODE END ADC1_Init 2 */
}

/**
 * @brief ADC5 Initialization Function
 * @param None
 * @retval None
 */
static void MX_ADC5_Init(void) {
    /* USER CODE BEGIN ADC5_Init 0 */

    /* USER CODE END ADC5_Init 0 */

    ADC_ChannelConfTypeDef sConfig = {0};

    /* USER CODE BEGIN ADC5_Init 1 */

    /* USER CODE END ADC5_Init 1 */

    /** Common config
     */
    hadc5.Instance = ADC5;
    hadc5.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
    hadc5.Init.Resolution = ADC_RESOLUTION_12B;
    hadc5.Init.DataAlign = ADC_DATAALIGN_RIGHT;
    hadc5.Init.GainCompensation = 0;
    hadc5.Init.ScanConvMode = ADC_SCAN_DISABLE;
    hadc5.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
    hadc5.Init.LowPowerAutoWait = DISABLE;
    hadc5.Init.ContinuousConvMode = DISABLE;
    hadc5.Init.NbrOfConversion = 1;
    hadc5.Init.DiscontinuousConvMode = DISABLE;
    hadc5.Init.ExternalTrigConv = ADC_SOFTWARE_START;
    hadc5.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
    hadc5.Init.DMAContinuousRequests = DISABLE;
    hadc5.Init.Overrun = ADC_OVR_DATA_PRESERVED;
    hadc5.Init.OversamplingMode = DISABLE;
    if (HAL_ADC_Init(&hadc5) != HAL_OK) {
        Error_Handler();
    }

    /** Configure Regular Channel
     */
    sConfig.Channel = ADC_CHANNEL_1;
    sConfig.Rank = ADC_REGULAR_RANK_1;
    sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;
    sConfig.SingleDiff = ADC_SINGLE_ENDED;
    sConfig.OffsetNumber = ADC_OFFSET_NONE;
    sConfig.Offset = 0;
    if (HAL_ADC_ConfigChannel(&hadc5, &sConfig) != HAL_OK) {
        Error_Handler();
    }
    /* USER CODE BEGIN ADC5_Init 2 */

    /* USER CODE END ADC5_Init 2 */
}

/**
 * @brief LPUART1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_LPUART1_UART_Init(void) {
    /* USER CODE BEGIN LPUART1_Init 0 */

    /* USER CODE END LPUART1_Init 0 */

    /* USER CODE BEGIN LPUART1_Init 1 */

    /* USER CODE END LPUART1_Init 1 */
    hlpuart1.Instance = LPUART1;
    hlpuart1.Init.BaudRate = 115200;
    hlpuart1.Init.WordLength = UART_WORDLENGTH_8B;
    hlpuart1.Init.StopBits = UART_STOPBITS_1;
    hlpuart1.Init.Parity = UART_PARITY_NONE;
    hlpuart1.Init.Mode = UART_MODE_TX_RX;
    hlpuart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    hlpuart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
    hlpuart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
    hlpuart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
    if (HAL_UART_Init(&hlpuart1) != HAL_OK) {
        Error_Handler();
    }
    if (HAL_UARTEx_SetTxFifoThreshold(&hlpuart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK) {
        Error_Handler();
    }
    if (HAL_UARTEx_SetRxFifoThreshold(&hlpuart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK) {
        Error_Handler();
    }
    if (HAL_UARTEx_DisableFifoMode(&hlpuart1) != HAL_OK) {
        Error_Handler();
    }
    /* USER CODE BEGIN LPUART1_Init 2 */

    /* USER CODE END LPUART1_Init 2 */
}

/**
 * @brief USART3 Initialization Function
 * @param None
 * @retval None
 */
static void MX_USART3_UART_Init(void) {
    /* USER CODE BEGIN USART3_Init 0 */

    /* USER CODE END USART3_Init 0 */

    /* USER CODE BEGIN USART3_Init 1 */

    /* USER CODE END USART3_Init 1 */
    huart3.Instance = USART3;
    huart3.Init.BaudRate = 115200;
    huart3.Init.WordLength = UART_WORDLENGTH_8B;
    huart3.Init.StopBits = UART_STOPBITS_1;
    huart3.Init.Parity = UART_PARITY_NONE;
    huart3.Init.Mode = UART_MODE_TX_RX;
    huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    huart3.Init.OverSampling = UART_OVERSAMPLING_16;
    huart3.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
    huart3.Init.ClockPrescaler = UART_PRESCALER_DIV1;
    huart3.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
    if (HAL_UART_Init(&huart3) != HAL_OK) {
        Error_Handler();
    }
    if (HAL_UARTEx_SetTxFifoThreshold(&huart3, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK) {
        Error_Handler();
    }
    if (HAL_UARTEx_SetRxFifoThreshold(&huart3, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK) {
        Error_Handler();
    }
    if (HAL_UARTEx_DisableFifoMode(&huart3) != HAL_OK) {
        Error_Handler();
    }
    /* USER CODE BEGIN USART3_Init 2 */

    /* USER CODE END USART3_Init 2 */
}

/**
 * @brief TIM1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM1_Init(void) {
    /* USER CODE BEGIN TIM1_Init 0 */

    /* USER CODE END TIM1_Init 0 */

    TIM_Encoder_InitTypeDef sConfig = {0};
    TIM_MasterConfigTypeDef sMasterConfig = {0};

    /* USER CODE BEGIN TIM1_Init 1 */

    /* USER CODE END TIM1_Init 1 */
    htim1.Instance = TIM1;
    htim1.Init.Prescaler = 0;
    htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim1.Init.Period = 65535;
    htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    htim1.Init.RepetitionCounter = 0;
    htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
    sConfig.EncoderMode = TIM_ENCODERMODE_TI12;
    sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;
    sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
    sConfig.IC1Prescaler = TIM_ICPSC_DIV1;
    sConfig.IC1Filter = 0;
    sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;
    sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
    sConfig.IC2Prescaler = TIM_ICPSC_DIV1;
    sConfig.IC2Filter = 0;
    if (HAL_TIM_Encoder_Init(&htim1, &sConfig) != HAL_OK) {
        Error_Handler();
    }
    sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
    sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
    sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
    if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK) {
        Error_Handler();
    }
    /* USER CODE BEGIN TIM1_Init 2 */

    /* USER CODE END TIM1_Init 2 */
}

/**
 * @brief TIM2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM2_Init(void) {
    /* USER CODE BEGIN TIM2_Init 0 */

    /* USER CODE END TIM2_Init 0 */

    TIM_ClockConfigTypeDef sClockSourceConfig = {0};
    TIM_MasterConfigTypeDef sMasterConfig = {0};
    TIM_OC_InitTypeDef sConfigOC = {0};

    /* USER CODE BEGIN TIM2_Init 1 */

    /* USER CODE END TIM2_Init 1 */
    htim2.Instance = TIM2;
    htim2.Init.Prescaler = 0;
    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim2.Init.Period = 9999;
    htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
    if (HAL_TIM_Base_Init(&htim2) != HAL_OK) {
        Error_Handler();
    }
    sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
    if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK) {
        Error_Handler();
    }
    if (HAL_TIM_PWM_Init(&htim2) != HAL_OK) {
        Error_Handler();
    }
    sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
    sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
    if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK) {
        Error_Handler();
    }
    sConfigOC.OCMode = TIM_OCMODE_PWM1;
    sConfigOC.Pulse = 0;
    sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
    sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
    if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK) {
        Error_Handler();
    }
    if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_2) != HAL_OK) {
        Error_Handler();
    }
    if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_3) != HAL_OK) {
        Error_Handler();
    }
    if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_4) != HAL_OK) {
        Error_Handler();
    }
    /* USER CODE BEGIN TIM2_Init 2 */

    /* USER CODE END TIM2_Init 2 */
    HAL_TIM_MspPostInit(&htim2);
}

/**
 * @brief TIM3 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM3_Init(void) {
    /* USER CODE BEGIN TIM3_Init 0 */

    /* USER CODE END TIM3_Init 0 */

    TIM_Encoder_InitTypeDef sConfig = {0};
    TIM_MasterConfigTypeDef sMasterConfig = {0};

    /* USER CODE BEGIN TIM3_Init 1 */

    /* USER CODE END TIM3_Init 1 */
    htim3.Instance = TIM3;
    htim3.Init.Prescaler = 0;
    htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim3.Init.Period = 65535;
    htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
    sConfig.EncoderMode = TIM_ENCODERMODE_TI12;
    sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;
    sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
    sConfig.IC1Prescaler = TIM_ICPSC_DIV1;
    sConfig.IC1Filter = 0;
    sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;
    sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
    sConfig.IC2Prescaler = TIM_ICPSC_DIV1;
    sConfig.IC2Filter = 0;
    if (HAL_TIM_Encoder_Init(&htim3, &sConfig) != HAL_OK) {
        Error_Handler();
    }
    sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
    sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
    if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK) {
        Error_Handler();
    }
    /* USER CODE BEGIN TIM3_Init 2 */

    /* USER CODE END TIM3_Init 2 */
}

/**
 * @brief TIM4 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM4_Init(void) {
    /* USER CODE BEGIN TIM4_Init 0 */

    /* USER CODE END TIM4_Init 0 */

    TIM_Encoder_InitTypeDef sConfig = {0};
    TIM_MasterConfigTypeDef sMasterConfig = {0};

    /* USER CODE BEGIN TIM4_Init 1 */

    /* USER CODE END TIM4_Init 1 */
    htim4.Instance = TIM4;
    htim4.Init.Prescaler = 0;
    htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim4.Init.Period = 65535;
    htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
    sConfig.EncoderMode = TIM_ENCODERMODE_TI12;
    sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;
    sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
    sConfig.IC1Prescaler = TIM_ICPSC_DIV1;
    sConfig.IC1Filter = 0;
    sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;
    sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
    sConfig.IC2Prescaler = TIM_ICPSC_DIV1;
    sConfig.IC2Filter = 0;
    if (HAL_TIM_Encoder_Init(&htim4, &sConfig) != HAL_OK) {
        Error_Handler();
    }
    sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
    sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
    if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK) {
        Error_Handler();
    }
    /* USER CODE BEGIN TIM4_Init 2 */

    /* USER CODE END TIM4_Init 2 */
}

/**
 * @brief TIM5 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM5_Init(void) {
    /* USER CODE BEGIN TIM5_Init 0 */

    /* USER CODE END TIM5_Init 0 */

    TIM_ClockConfigTypeDef sClockSourceConfig = {0};
    TIM_MasterConfigTypeDef sMasterConfig = {0};
    TIM_IC_InitTypeDef sConfigIC = {0};

    /* USER CODE BEGIN TIM5_Init 1 */

    /* USER CODE END TIM5_Init 1 */
    htim5.Instance = TIM5;
    htim5.Init.Prescaler = 9;
    htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim5.Init.Period = 4294967295;
    htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    htim5.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
    if (HAL_TIM_Base_Init(&htim5) != HAL_OK) {
        Error_Handler();
    }
    sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
    if (HAL_TIM_ConfigClockSource(&htim5, &sClockSourceConfig) != HAL_OK) {
        Error_Handler();
    }
    if (HAL_TIM_IC_Init(&htim5) != HAL_OK) {
        Error_Handler();
    }
    sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
    sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
    if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK) {
        Error_Handler();
    }
    sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
    sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
    sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
    sConfigIC.ICFilter = 0;
    if (HAL_TIM_IC_ConfigChannel(&htim5, &sConfigIC, TIM_CHANNEL_2) != HAL_OK) {
        Error_Handler();
    }
    /* USER CODE BEGIN TIM5_Init 2 */

    /* USER CODE END TIM5_Init 2 */
}

/**
 * @brief TIM8 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM8_Init(void) {
    /* USER CODE BEGIN TIM8_Init 0 */

    /* USER CODE END TIM8_Init 0 */

    TIM_Encoder_InitTypeDef sConfig = {0};
    TIM_MasterConfigTypeDef sMasterConfig = {0};

    /* USER CODE BEGIN TIM8_Init 1 */

    /* USER CODE END TIM8_Init 1 */
    htim8.Instance = TIM8;
    htim8.Init.Prescaler = 0;
    htim8.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim8.Init.Period = 65535;
    htim8.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    htim8.Init.RepetitionCounter = 0;
    htim8.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
    sConfig.EncoderMode = TIM_ENCODERMODE_TI12;
    sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;
    sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
    sConfig.IC1Prescaler = TIM_ICPSC_DIV1;
    sConfig.IC1Filter = 0;
    sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;
    sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
    sConfig.IC2Prescaler = TIM_ICPSC_DIV1;
    sConfig.IC2Filter = 0;
    if (HAL_TIM_Encoder_Init(&htim8, &sConfig) != HAL_OK) {
        Error_Handler();
    }
    sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
    sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
    sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
    if (HAL_TIMEx_MasterConfigSynchronization(&htim8, &sMasterConfig) != HAL_OK) {
        Error_Handler();
    }
    /* USER CODE BEGIN TIM8_Init 2 */

    /* USER CODE END TIM8_Init 2 */
}

/**
 * @brief TIM15 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM15_Init(void) {
    /* USER CODE BEGIN TIM15_Init 0 */

    /* USER CODE END TIM15_Init 0 */

    TIM_ClockConfigTypeDef sClockSourceConfig = {0};
    TIM_MasterConfigTypeDef sMasterConfig = {0};

    /* USER CODE BEGIN TIM15_Init 1 */

    /* USER CODE END TIM15_Init 1 */
    htim15.Instance = TIM15;
    htim15.Init.Prescaler = 67;
    htim15.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim15.Init.Period = 49999;
    htim15.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    htim15.Init.RepetitionCounter = 0;
    htim15.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
    if (HAL_TIM_Base_Init(&htim15) != HAL_OK) {
        Error_Handler();
    }
    sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
    if (HAL_TIM_ConfigClockSource(&htim15, &sClockSourceConfig) != HAL_OK) {
        Error_Handler();
    }
    sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
    sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
    if (HAL_TIMEx_MasterConfigSynchronization(&htim15, &sMasterConfig) != HAL_OK) {
        Error_Handler();
    }
    /* USER CODE BEGIN TIM15_Init 2 */

    /* USER CODE END TIM15_Init 2 */
}

/**
 * @brief TIM20 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM20_Init(void) {
    /* USER CODE BEGIN TIM20_Init 0 */

    /* USER CODE END TIM20_Init 0 */

    TIM_MasterConfigTypeDef sMasterConfig = {0};
    TIM_OC_InitTypeDef sConfigOC = {0};
    TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};

    /* USER CODE BEGIN TIM20_Init 1 */

    /* USER CODE END TIM20_Init 1 */
    htim20.Instance = TIM20;
    htim20.Init.Prescaler = 0;
    htim20.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim20.Init.Period = 65535;
    htim20.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    htim20.Init.RepetitionCounter = 0;
    htim20.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
    if (HAL_TIM_PWM_Init(&htim20) != HAL_OK) {
        Error_Handler();
    }
    sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
    sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
    sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
    if (HAL_TIMEx_MasterConfigSynchronization(&htim20, &sMasterConfig) != HAL_OK) {
        Error_Handler();
    }
    sConfigOC.OCMode = TIM_OCMODE_PWM1;
    sConfigOC.Pulse = 0;
    sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
    sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
    sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
    sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
    sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
    if (HAL_TIM_PWM_ConfigChannel(&htim20, &sConfigOC, TIM_CHANNEL_3) != HAL_OK) {
        Error_Handler();
    }
    sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
    sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
    sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
    sBreakDeadTimeConfig.DeadTime = 0;
    sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
    sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
    sBreakDeadTimeConfig.BreakFilter = 0;
    sBreakDeadTimeConfig.BreakAFMode = TIM_BREAK_AFMODE_INPUT;
    sBreakDeadTimeConfig.Break2State = TIM_BREAK2_DISABLE;
    sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
    sBreakDeadTimeConfig.Break2Filter = 0;
    sBreakDeadTimeConfig.Break2AFMode = TIM_BREAK_AFMODE_INPUT;
    sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
    if (HAL_TIMEx_ConfigBreakDeadTime(&htim20, &sBreakDeadTimeConfig) != HAL_OK) {
        Error_Handler();
    }
    /* USER CODE BEGIN TIM20_Init 2 */

    /* USER CODE END TIM20_Init 2 */
    HAL_TIM_MspPostInit(&htim20);
}

/**
 * @brief GPIO Initialization Function
 * @param None
 * @retval None
 */
static void MX_GPIO_Init(void) {
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    /* USER CODE BEGIN MX_GPIO_Init_1 */
    /* USER CODE END MX_GPIO_Init_1 */

    /* GPIO Ports Clock Enable */
    __HAL_RCC_GPIOC_CLK_ENABLE();
    __HAL_RCC_GPIOF_CLK_ENABLE();
    __HAL_RCC_GPIOA_CLK_ENABLE();
    __HAL_RCC_GPIOB_CLK_ENABLE();

    /*Configure GPIO pin Output Level */
    HAL_GPIO_WritePin(GPIOC, GPIO_PIN_2 | GPIO_PIN_3 | GPIO_PIN_4, GPIO_PIN_RESET);

    /*Configure GPIO pin Output Level */
    HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);

    /*Configure GPIO pin Output Level */
    HAL_GPIO_WritePin(
        GPIOB,
        GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_6 | GPIO_PIN_7,
        GPIO_PIN_RESET);

    /*Configure GPIO pin : B1_Pin */
    GPIO_InitStruct.Pin = B1_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);

    /*Configure GPIO pins : PC2 PC3 PC4 */
    GPIO_InitStruct.Pin = GPIO_PIN_2 | GPIO_PIN_3 | GPIO_PIN_4;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

    /*Configure GPIO pin : LD2_Pin */
    GPIO_InitStruct.Pin = LD2_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);

    /*Configure GPIO pin : PA7 */
    GPIO_InitStruct.Pin = GPIO_PIN_7;
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /*Configure GPIO pins : PB11 PB13 PB14 PB4
                             PB5 PB6 PB7 */
    GPIO_InitStruct.Pin =
        GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_6 | GPIO_PIN_7;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    /* EXTI interrupt init*/
    HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);

    /* USER CODE BEGIN MX_GPIO_Init_2 */
    /* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

/**
 * @brief Timer period elapsed callback - Main control loop (100 Hz)
 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef* htim) {
    if (htim->Instance == TIM15) {
        // Check obstacle and stop if enabled
        if (obstacle_detected && obstacle_stop_enabled &&
            (mode == STATE_TRAJECTORY || mode == STATE_KINEMATICS)) {
            // Stop motors but keep mode (can resume later)
            Pwm[0] = Pwm[1] = Pwm[2] = Pwm[3] = 0;
            set_pwm(Pwm);
            if (mode == STATE_TRAJECTORY) {
                stop_trajectory();
                mode = STATE_IDLE;
            }
            return;
        }

        switch (mode) {
            case STATE_IDLE:
                Pwm[0] = Pwm[1] = Pwm[2] = Pwm[3] = 0;
                pid();
                break;

            case STATE_PWM:
                // Pwm values set by UART command
                pid();
                break;

            case STATE_SQUARE:
                if ((ka % 100) == 0) s = -s;
                if (ka > 10) {
                    int16_t val = s * STEP_SIZE;
                    Pwm[0] = Pwm[1] = Pwm[2] = Pwm[3] = val;
                } else {
                    Pwm[0] = Pwm[1] = Pwm[2] = Pwm[3] = 0;
                }
                pid();
                record_enc();
                break;

            case STATE_DRIVE:
                set_drive_pwm();
                pid();
                break;

            case STATE_VELOCITY:
                // Closed-loop velocity control
                velocity_pid();
                break;

            case STATE_KINEMATICS:
                // Convert kinematics to wheel velocities then apply PI control
                kinematics_to_wheel_vel(vx_ref, vy_ref, wz_ref);
                velocity_pid();
                break;

            case STATE_TRAJECTORY:
                // Trajectory references are set by output compare interrupt
                velocity_pid();
                break;

            default:
                mode = STATE_IDLE;
                break;
        }

        // LED heartbeat
        if (--tic == 0) {
            tic = 50;
            HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
        }
    }
}

/* USER CODE END 4 */

/**
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void Error_Handler(void) {
    /* USER CODE BEGIN Error_Handler_Debug */
    /* User can add his own implementation to report the HAL error return state */
    __disable_irq();
    while (1) {
    }
    /* USER CODE END Error_Handler_Debug */
}
#ifdef USE_FULL_ASSERT
/**
 * @brief  Reports the name of the source file and the source line number
 *         where the assert_param error has occurred.
 * @param  file: pointer to the source file name
 * @param  line: assert_param error line source number
 * @retval None
 */
void assert_failed(uint8_t* file, uint32_t line) {
    /* USER CODE BEGIN 6 */
    /* User can add his own implementation to report the file name and line number,
       ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
    /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
